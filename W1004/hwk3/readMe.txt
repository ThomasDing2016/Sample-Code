readMe.txt

The purpose of this program is to implement a simple game between two players. Each player is either odd or even, and is able to play the numbers 1 or 2. If the sum of the players' throws equals the parity of either, (that is, when the sum of throws is odd and player 1 is odd, for example) the player with the right parity gets the points added to his/he account while the other player loses those points.
There are three types of games within this program: human vs. computer, computer vs. computer and a simulation of the game over the long run with differing strategies for two computer players in order to determine the fairness of the game. Fairness is defined as there not being a strategy that either player can use to always get a positive balance over the course of 1000 trials or more, no matter what the strategy of player 2 is.

Player class

The player class creates a player based on three parameters: one determines whether that player is a human or a computer (type), the second sets a value for sim that will activate simulation mode if it equals one and the third is the player's strategy (strat) --in human vs. computer as well as computer vs. computer games, the strategy for computer is hardcoded to 0.50 and the human player obviously decides his or her own strategy. The player class has various methods: the most important is its "play" method, which branches off into "playHuman" and "playComp." The method to play for a human simply prompts the user to select 1 or 2 as the number to play. The play method for computers either hardcodes the strategy for computer --throwing 2 if a randomly generated number is greater than 0.5 and 1 if the opposite if true -- or simply has a place holder for strategy to be determined within the Simulation class, with the same type of algorithm in place to determine whether to throw 1 or 2.
Player is also able to ask the user whether he or she wants to play again, adds or subtracts the sum of players' throws from a given player's balance, resets the balance of each player to 0, and returns the current throw and balance of each player.

Game class

The Game class creates a game with the parameters necessary to in turn create a new instance of Player. Its main method, not unlike Player, is "run," which branches off into runHuman, runComp and runSimulation depending on whether isHuman for player 1 is true. Each run method works similarly although it observes certain differences: all the run methods assign the players' parity (runHuman asks the user for his or her preference, however), and set up an algorithm that calls upon methods from the Player class to return each payer's throws, sum them into a playerSum and compare that to each player's given parity. For example, if player 1 is odd (as it is hardcoded to be in the runComp and runSim methods), and the playerSum of that round is also odd, the sum of the throws is both added to player 1's balance, and subtracted from player 2's. At the end of each round, each run prints the total for each player. Only runHuman and runComp ask the user whether he or she would like to keep playing or watching computers play. runSim, however, carries out one run and places the responsibility of iteration on the Simulation class, which will call upon runSim.
Game contains other methods, such as play and watchAgain, which ask the user to decide whether to keep carrying out rounds of the game. it also has a reset method which calls upon reset from Player and sets each player's balance to 0. The getWinner method if also important, as it is the one to return the winner for the total rounds played: it does so by determining which of the two players' balances is higher.

Simulation class
The simulation class contains the algorithm that determines whether the game is skewed to the advantage of one player over the other. Its purpose is to determine whether there is a single strategy that player 1 (or 2) can use so that no matter what strategy the opposing player uses, player 1's balance always ends up positive. The method decides the fairness as follows: First, an outer loop augments the value of strategy 1 by 0.01 (having started the strategy at 0.01) while strategy 2 is also increased 0.01 after each game, consisting of 1000 trials. After 1000 trials where strategy 1 is pitted against the same strategy 2, the updated balances of player 1 and player 2 are compared to determine the overall winner within the 1000 trials. If player 1 has won the most games, p1Wins is incremented by 1 and the opposite, for player 2, is true as well. Only after p1Wins is updated does the strategy of p1 go up by 0.01, to be tried again with all the possible player 2 strategies. As strategy 2 is being increased every other 1000 trials, if the number of times p1Wins equals the number of times strategy 2 is incremented to be less than or equal to 1 (that is, if there is ever a time where strategy 1 won all the games played with all different strat2's), then the game is determined to be unfair and the strategy associates with that game is printed out.

GameTest

GameTest first welcomes the user to the game, and immediately asks him or her is she or he will be playing as a human. If the user says they are not, tester then asks if they are computers on simulation mode. If the answer to this question is yes (or 1), test creates a new instance of the class Simulation and "simulates." If simulation is not equal to 1, a new game is created and ran until the user tires of watching the computers play.
